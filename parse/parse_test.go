package parse

import (
	"gorilla/lex"
	"testing"
)

type Pair struct {
	input  string
	output string
}

func TestBlockStmt(t *testing.T) {
	tt := []Pair{
		{"{ a; b; }", "(block a b)"},
		{"{ if (a) { b; } }", "(block (if a (block b) ))"},
	}

	check(t, tt)
}

func TestIfStmt(t *testing.T) {
	tt := []Pair{
		{"if (true) { true; }", "(if true (block true) )"},
		{"if (true) { true; } else { false; }", "(if true (block true) (block false))"},
		{"if (a) { if (b) { c; } else { d; }}", "(if a (block (if b (block c) (block d))) )"},
	}

	check(t, tt)
}
func TestInfix(t *testing.T) {
	tt := []Pair{
		{"1 . 1;", "(1 . 1)"},
		{"1 * 1;", "(1 * 1)"},
		{"1 / 1;", "(1 / 1)"},
		{"1 % 1;", "(1 % 1)"},
		{"1 + 1;", "(1 + 1)"},
		{"1 - 1;", "(1 - 1)"},
		{"1 << 1;", "(1 << 1)"},
		{"1 >> 1;", "(1 >> 1)"},
		{"1 < 1;", "(1 < 1)"},
		{"1 > 1;", "(1 > 1)"},
		{"1 <= 1;", "(1 <= 1)"},
		{"1 >= 1;", "(1 >= 1)"},
		{"1 == 1;", "(1 == 1)"},
		{"1 != 1;", "(1 != 1)"},
		{"1 & 1;", "(1 & 1)"},
		{"1 ^ 1;", "(1 ^ 1)"},
		{"1 | 1;", "(1 | 1)"},
		{"1 && 1;", "(1 && 1)"},
		{"1 || 1;", "(1 || 1)"},
	}
	check(t, tt)
}

func TestAssign(t *testing.T) {
	tt := []Pair{
		{"1 = 2;", "(1 = 2)"},
		{"1 += 2;", "(1 += 2)"},
		{"1 -= 2;", "(1 -= 2)"},
		{"1 /= 2;", "(1 /= 2)"},
		{"1 *= 2;", "(1 *= 2)"},
		{"1 %= 2;", "(1 %= 2)"},
		{"1 <<= 2;", "(1 <<= 2)"},
		{"1 >>= 2;", "(1 >>= 2)"},
		{"1 &= 2;", "(1 &= 2)"},
		{"1 ^= 2;", "(1 ^= 2)"},
		{"1 |= 2;", "(1 |= 2)"},
	}
	check(t, tt)
}

func TestPrefixOpt(t *testing.T) {
	tt := []Pair{
		{"!true;", "(! true)"},
		{"++a;", "(++ a)"},
		{"--a;", "(-- a)"},
		{"+a;", "(+ a)"},
		{"-a;", "(- a)"},
		{"&a;", "(& a)"},
		{"~a;", "(~ a)"},
	}
	check(t, tt)
}

func TestPostfixOpt(t *testing.T) {
	tt := []Pair{
		{"a++;", "(a ++)"},
	}
	check(t, tt)
}

func TestTernary(t *testing.T) {
	tt := []Pair{
		{"1 ? 2 : 3;", "(1 2 3)"},
	}
	check(t, tt)
}

func TestCall(t *testing.T) {
	tt := []Pair{
		{"a();", "(a )"},
		{"a(1);", "(a 1)"},
		{"a(1, 2);", "(a 1 2)"},
		{"a(1, b(2 + 3));", "(a 1 (b (2 + 3)))"},
	}
	check(t, tt)
}

func TestIndexing(t *testing.T) {
	tt := []Pair{
		{"a[i];", "(a i)"},
		{"a[i+1];", "(a (i + 1))"},
	}
	check(t, tt)
}
func TestPrecedence(t *testing.T) {
	tt := []Pair{
		{"++a++;", "(++ (a ++))"},
		{"++a--;", "(++ (a --))"},
		{"++a.b;", "(++ (a . b))"},
		{"++a * b;", "((++ a) * b)"},
		{"--a * b;", "((-- a) * b)"},
		{"!a * b;", "((! a) * b)"},
		{"~a * b;", "((~ a) * b)"},
		{"1 * 2 + 3;", "((1 * 2) + 3)"},
		{"1 / 2 + 3;", "((1 / 2) + 3)"},
		{"1 % 2 + 3;", "((1 % 2) + 3)"},
		{"1 + 2 << 3;", "((1 + 2) << 3)"},
		{"1 - 2 << 3;", "((1 - 2) << 3)"},
		{"1 << 2 < 3;", "((1 << 2) < 3)"},
		{"1 >> 2 < 3;", "((1 >> 2) < 3)"},
		{"1 <= 2 == 3;", "((1 <= 2) == 3)"},
		{"1 >= 2 == 3;", "((1 >= 2) == 3)"},
		{"1 < 2 == 3;", "((1 < 2) == 3)"},
		{"1 > 2 == 3;", "((1 > 2) == 3)"},
		{"1 == 2 & 3;", "((1 == 2) & 3)"},
		{"1 != 2 & 3;", "((1 != 2) & 3)"},
		{"1 & 2 ^ 3;", "((1 & 2) ^ 3)"},
		{"1 ^ 2 | 3;", "((1 ^ 2) | 3)"},
		{"1 && 2 || 3;", "((1 && 2) || 3)"},
		{"1 || 2 ? 3 : 4;", "((1 || 2) 3 4)"},
		{"a = 1 ? 3 : 4;", "(a = (1 3 4))"},
		{"a += 1 ? 3 : 4;", "(a += (1 3 4))"},
		{"a -= 1 ? 3 : 4;", "(a -= (1 3 4))"},
		{"a *= 1 ? 3 : 4;", "(a *= (1 3 4))"},
		{"a /= 1 ? 3 : 4;", "(a /= (1 3 4))"},
		{"a &= 1 ? 3 : 4;", "(a &= (1 3 4))"},
		{"a <<= 1 ? 3 : 4;", "(a <<= (1 3 4))"},
		{"a >>= 1 ? 3 : 4;", "(a >>= (1 3 4))"},
		{"a &= 1 ? 3 : 4;", "(a &= (1 3 4))"},
		{"a ^= 1 ? 3 : 4;", "(a ^= (1 3 4))"},
		{"a |= 1 ? 3 : 4;", "(a |= (1 3 4))"},
	}
	check(t, tt)
}

func TestAssociativity(t *testing.T) {
	tt := []Pair{
		{"a++++;", "((a ++) ++)"},
		{"a----;", "((a --) --)"},
		{"a()();", "((a ) )"},
		{"a[1][1];", "((a 1) 1)"},
		{"a.b.c;", "((a . b) . c)"},
		{"++++a;", "(++ (++ a))"},
		{"----a;", "(-- (-- a))"},
		{"- -a;", "(- (- a))"},
		{"+ +a;", "(+ (+ a))"},
		{"!!a;", "(! (! a))"},
		{"~~a;", "(~ (~ a))"},
		{"1 * 2 * 3;", "((1 * 2) * 3)"},
		{"1 / 2 / 3;", "((1 / 2) / 3)"},
		{"1 % 2 % 3;", "((1 % 2) % 3)"},
		{"1 + 2 + 3;", "((1 + 2) + 3)"},
		{"1 << 2 << 3;", "((1 << 2) << 3)"},
		{"1 >> 2 >> 3;", "((1 >> 2) >> 3)"},
		{"1 < 2 < 3;", "((1 < 2) < 3)"},
		{"1 > 2 > 3;", "((1 > 2) > 3)"},
		{"1 >= 2 >= 3;", "((1 >= 2) >= 3)"},
		{"1 <= 2 <= 3;", "((1 <= 2) <= 3)"},
		{"1 == 2 == 3;", "((1 == 2) == 3)"},
		{"1 != 2 != 3;", "((1 != 2) != 3)"},
		{"1 & 2 & 3;", "((1 & 2) & 3)"},
		{"1 ^ 2 ^ 3;", "((1 ^ 2) ^ 3)"},
		{"1 | 2 | 3;", "((1 | 2) | 3)"},
		{"1 && 2 && 3;", "((1 && 2) && 3)"},
		{"1 || 2 || 3;", "((1 || 2) || 3)"},
		{"1 ? 2 : 3 ? 2 : 3;", "((1 2 3) 2 3)"},
		{"1 = 2 = 3;", "((1 = 2) = 3)"},
		{"1 += 2 += 3;", "((1 += 2) += 3)"},
		{"1 -= 2 -= 3;", "((1 -= 2) -= 3)"},
		{"1 *= 2 *= 3;", "((1 *= 2) *= 3)"},
		{"1 /= 2 /= 3;", "((1 /= 2) /= 3)"},
		{"1 %= 2 %= 3;", "((1 %= 2) %= 3)"},
		{"1 <<= 2 <<= 3;", "((1 <<= 2) <<= 3)"},
		{"1 >>= 2 >>= 3;", "((1 >>= 2) >>= 3)"},
		{"1 &= 2 &= 3;", "((1 &= 2) &= 3)"},
		{"1 ^= 2 ^= 3;", "((1 ^= 2) ^= 3)"},
		{"1 |= 2 |= 3;", "((1 |= 2) |= 3)"},
	}
	check(t, tt)
}

func check(t *testing.T, tt []Pair) {
	for i, test := range tt {
		l := lex.New(test.input)
		p := New(l)
		tree, err := p.Parse()

		for _, e := range err {
			t.Errorf(e.Error())
		}

		if len(p.err) > 0 {
			continue
		} else if len(tree) == 0 {
			t.Errorf("no ast produced")
			continue
		}

		if test.output != tree[0].String() {
			t.Errorf("expected \"%s\", got \"%s\" at tt[%d]",
				test.output, tree[0].String(), i)
		}
	}
}
